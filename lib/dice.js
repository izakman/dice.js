// Generated by CoffeeScript 1.7.1
var DiceCollection, Die, RollExpressionResult, RollResult, d, parse,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice;

Die = (function() {
  function Die(numOfSides) {
    var _i, _ref, _results;
    this.numOfSides = numOfSides;
    this.another = __bind(this.another, this);
    this.isSameAs = __bind(this.isSameAs, this);
    this.toString = __bind(this.toString, this);
    this.roll = __bind(this.roll, this);
    this.sides = (function() {
      _results = [];
      for (var _i = 1, _ref = this.numOfSides; 1 <= _ref ? _i <= _ref : _i >= _ref; 1 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    this.result = null;
  }

  Die.prototype.roll = function(times) {
    if (times === 0) {
      throw new RangeError("Argument can't be 0");
    }
    times = times > 1 ? times : 1;
    return new RollResult(this, (function() {
      var _i, _results;
      _results = [];
      for (_i = 1; 1 <= times ? _i <= times : _i >= times; 1 <= times ? _i++ : _i--) {
        _results.push(this.sides[Math.floor(Math.random() * this.numOfSides)]);
      }
      return _results;
    }).call(this));
  };

  Die.prototype.toString = function() {
    return "d" + this.numOfSides;
  };

  Die.prototype.isSameAs = function(die) {
    if (!(die instanceof Die)) {
      throw new TypeError("Argument should be a Die object");
    }
    return this.sides.join(',') === die.sides.join(',');
  };

  Die.prototype.another = function() {
    return new Die(this.numOfSides);
  };

  Die.roll = function(sides, times) {
    return new Die(sides).roll(times);
  };

  return Die;

})();

RollResult = (function() {
  function RollResult(die, rolls) {
    var roll, _i, _len, _ref;
    this.die = die;
    this.rolls = rolls;
    this.toString = __bind(this.toString, this);
    if (!(this.die instanceof Die)) {
      throw new SyntaxError("First argument must a Die object");
    }
    if (Object.prototype.toString.call(this.rolls) !== '[object Array]') {
      throw new SyntaxError("Second argument must be an array");
    }
    this.total = 0;
    _ref = this.rolls;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      roll = _ref[_i];
      this.total += roll;
    }
    this.times = this.rolls.length;
  }

  RollResult.prototype.toString = function() {
    var rollsString, timesString;
    rollsString = this.rolls.length > 1 ? "{" + (this.rolls.join("+")) + "}" : "";
    timesString = this.times > 1 ? "" + this.times : "";
    return "" + this.total + "[" + timesString + "d" + this.die.numOfSides + rollsString + "]";
  };

  return RollResult;

})();

RollExpressionResult = (function() {
  var parseDice, parseModifier, parseOperator;

  parseDice = function(diceExp) {
    var values;
    if (!/^([1-9][0-9]*)?(d)([1-9][0-9]*)$/.test(diceExp)) {
      return null;
    }
    values = diceExp.split("d");
    return Die.roll(values[1], values[0] ? values[0] : 1);
  };

  parseModifier = function(modExp) {
    return (/^(0|[1-9](\d*))$/.test(modExp) ? parseInt(modExp) : null);
  };

  parseOperator = function(operatorExp) {
    if (operatorExp === '+' || operatorExp === '-') {
      return operatorExp;
    } else {
      return null;
    }
  };

  function RollExpressionResult(stringExpression) {
    var exp, expResult, expressionArray, prevOperator, value, _i, _len;
    this.stringExpression = stringExpression;
    this.toString = __bind(this.toString, this);
    this.total = 0;
    this.results = [];
    prevOperator = '+';
    expressionArray = this.stringExpression.split(" ");
    for (_i = 0, _len = expressionArray.length; _i < _len; _i++) {
      exp = expressionArray[_i];
      expResult = parseModifier(exp) || parseDice(exp) || parseOperator(exp) || null;
      if (expResult == null) {
        throw new SyntaxError("\"" + exp + "\" is not valid");
      }
      this.results.push(expResult);
      if (parseOperator(expResult)) {
        prevOperator = expResult;
        continue;
      }
      value = (expResult instanceof RollResult ? expResult.total : expResult);
      if (prevOperator === '+') {
        this.total += value;
      } else {
        this.total -= value;
      }
    }
  }

  RollExpressionResult.prototype.toString = function() {
    var exp;
    return "" + this.total + ": " + (((function() {
      var _i, _len, _ref, _results;
      _ref = this.results;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        exp = _ref[_i];
        _results.push(exp.toString());
      }
      return _results;
    }).call(this)).join(" "));
  };

  return RollExpressionResult;

})();

DiceCollection = (function() {
  function DiceCollection() {
    var dice;
    dice = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.roll = __bind(this.roll, this);
    this.grab = __bind(this.grab, this);
    this.remove = __bind(this.remove, this);
    this.add = __bind(this.add, this);
    this.dice = [];
    if (dice != null) {
      this.add(dice);
    }
  }

  DiceCollection.prototype.add = function() {
    var dice, die, _i, _len, _results;
    dice = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (dice == null) {
      throw new SyntaxError("add() must have at least one argument");
    }
    if (Object.prototype.toString.call(dice[0]) === '[object Array]') {
      dice = dice[0];
    }
    _results = [];
    for (_i = 0, _len = dice.length; _i < _len; _i++) {
      die = dice[_i];
      if (!(die instanceof Die)) {
        throw new TypeError("Arguments should be Die objects or an Array of Die objects");
      }
      _results.push(this.dice.push(die));
    }
    return _results;
  };

  DiceCollection.prototype.remove = function() {
    var dice, diceIndex, die, index, isInt, original, removedDice, _i, _j, _k, _len, _len1, _len2, _ref;
    dice = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (dice == null) {
      throw new SyntaxError("remove() must have at least one argument");
    }
    if (Object.prototype.toString.call(dice[0]) === '[object Array]') {
      dice = dice[0];
    }
    isInt = function(val) {
      return (typeof val === 'number') && (val % 1 === 0);
    };
    removedDice = [];
    if (isInt(dice[0])) {
      for (_i = 0, _len = dice.length; _i < _len; _i++) {
        diceIndex = dice[_i];
        if (!isInt(diceIndex)) {
          throw new TypeError("Provided Array elements should all be integers");
        }
        removedDice.push(this.dice.splice(diceIndex, 1));
      }
    } else {
      for (_j = 0, _len1 = dice.length; _j < _len1; _j++) {
        die = dice[_j];
        if (!(die instanceof Die)) {
          throw new TypeError("Arguments should be Die objects");
        }
        _ref = this.dice;
        for (index = _k = 0, _len2 = _ref.length; _k < _len2; index = ++_k) {
          original = _ref[index];
          if (original.isSameAs(die)) {
            removedDice.push(this.dice.splice(index, 1));
            break;
          }
        }
      }
    }
    if (removedDice.length === 0) {
      throw new RangeError("Die not in DiceCollection");
    }
    if (removedDice.length === 1) {
      return removedDice[0];
    } else {
      return new DiceCollection(removedDice);
    }
  };

  DiceCollection.prototype.grab = function(number) {
    var indexes;
    indexes = (function() {
      var _i, _results;
      _results = [];
      for (_i = 1; 1 <= number ? _i <= number : _i >= number; 1 <= number ? _i++ : _i--) {
        _results.push(Math.floor(Math.random() * this.dice.length));
      }
      return _results;
    }).call(this);
    return remove(indexes);
  };

  DiceCollection.prototype.roll = function(times, giveTotals, allTotaled) {
    var getTotal, rollOnce, rolls;
    if (times === 0) {
      throw new RangeError("Argument can't be 0");
    }
    rollOnce = (function(_this) {
      return function() {
        var die, _i, _len, _ref, _results;
        _ref = _this.dice;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          die = _ref[_i];
          _results.push(die.roll());
        }
        return _results;
      };
    })(this);
    getTotal = (function(_this) {
      return function(roll) {
        var total, val, _i, _len;
        total = 0;
        for (_i = 0, _len = roll.length; _i < _len; _i++) {
          val = roll[_i];
          total += val;
        }
        return total;
      };
    })(this);
    if (times > 1) {
      rolls = (function() {
        var _i, _results;
        _results = [];
        for (_i = 1; 1 <= times ? _i <= times : _i >= times; 1 <= times ? _i++ : _i--) {
          if (giveTotals) {
            _results.push(getTotal(rollOnce()));
          } else {
            _results.push(rollOnce());
          }
        }
        return _results;
      })();
      if (allTotaled) {
        return getTotal(rolls);
      } else {
        return rolls;
      }
    } else {
      if (giveTotals) {
        return getTotal(rollOnce());
      } else {
        return rollOnce();
      }
    }
  };

  return DiceCollection;

})();

parse = function(diceExpressionString) {
  return new RollExpressionResult(diceExpressionString);
};

d = function(sides) {
  return new Die(sides);
};

module.exports = {
  Die: Die,
  DiceCollection: DiceCollection,
  RollResult: RollResult,
  RollExpressionResult: RollExpressionResult,
  parse: parse,
  d: d
};
